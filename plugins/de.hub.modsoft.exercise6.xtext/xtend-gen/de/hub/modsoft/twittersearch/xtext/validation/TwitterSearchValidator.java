/**
 * generated by Xtext
 */
package de.hub.modsoft.twittersearch.xtext.validation;

import de.hub.modsoft.twittersearch.model.Condition;
import de.hub.modsoft.twittersearch.model.Search;
import de.hub.modsoft.twittersearch.model.TwitterFieldDeclaration;
import de.hub.modsoft.twittersearch.model.TwitterObjectTypeDeclaration;
import de.hub.modsoft.twittersearch.model.TwitterSearchPackage;
import de.hub.modsoft.twittersearch.model.TwitterTypeDeclaration;
import de.hub.modsoft.twittersearch.xtext.validation.AbstractTwitterSearchValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;

@SuppressWarnings("all")
public class TwitterSearchValidator extends AbstractTwitterSearchValidator {
  @Check(CheckType.FAST)
  public void checkConditionFieldPartOfSearchType(final Condition condition) {
    EObject _eContainer = condition.eContainer();
    final Search search = ((Search) _eContainer);
    TwitterObjectTypeDeclaration _searchType = search.getSearchType();
    EList<TwitterFieldDeclaration> _fields = _searchType.getFields();
    TwitterFieldDeclaration _fieldDeclaration = condition.getFieldDeclaration();
    boolean _contains = _fields.contains(_fieldDeclaration);
    boolean _not = (!_contains);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      TwitterFieldDeclaration _fieldDeclaration_1 = condition.getFieldDeclaration();
      String _name = _fieldDeclaration_1.getName();
      _builder.append(_name, "");
      _builder.append(" is not a field of the requested search type ");
      TwitterObjectTypeDeclaration _searchType_1 = search.getSearchType();
      String _name_1 = _searchType_1.getName();
      _builder.append(_name_1, "");
      EReference _condition_FieldDeclaration = TwitterSearchPackage.eINSTANCE.getCondition_FieldDeclaration();
      this.error(_builder.toString(), _condition_FieldDeclaration);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkConditionTypeMatchesFieldType(final Condition condition) {
    EClass _eClass = condition.eClass();
    String _name = _eClass.getName();
    String _lowerCase = _name.toLowerCase();
    TwitterFieldDeclaration _fieldDeclaration = condition.getFieldDeclaration();
    TwitterTypeDeclaration _type = _fieldDeclaration.getType();
    String _name_1 = _type.getName();
    String _lowerCase_1 = _name_1.toLowerCase();
    boolean _startsWith = _lowerCase.startsWith(_lowerCase_1);
    boolean _not = (!_startsWith);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      TwitterFieldDeclaration _fieldDeclaration_1 = condition.getFieldDeclaration();
      String _name_2 = _fieldDeclaration_1.getName();
      _builder.append(_name_2, "");
      _builder.append(" has the wrong type.");
      EReference _condition_FieldDeclaration = TwitterSearchPackage.eINSTANCE.getCondition_FieldDeclaration();
      this.error(_builder.toString(), _condition_FieldDeclaration);
    }
  }
}
