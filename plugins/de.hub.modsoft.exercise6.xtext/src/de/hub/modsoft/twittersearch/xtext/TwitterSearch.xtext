grammar de.hub.modsoft.twittersearch.xtext.TwitterSearch with org.eclipse.xtext.common.Terminals

import "http://www.hu-berlin.de/modsoft/TwitterSearch/1.0" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns Twitter:
	{Twitter}
	"configuration" ":"
	(objectTypes+=ObjectTypeDclr)*
	"searches" ":"
	(searches+=Search)*
;

ObjectTypeDclr returns TwitterObjectType:
	"objecttype" name=ID '{'
		(fields+=FieldDclr)*
	'}'
;

FieldDclr returns FieldDeclaration:	
	"field" name=ID ':' fieldType=FieldType
;

enum FieldType returns FieldTypes: boolean = 'BOOLEAN' | int = 'INT' | string = 'STRING';

Search returns Search:
	{Search}
	"search" ";"
;

enum DistanceUnit returns DistanceUnit:	miles = 'mi' | kilometers = 'km';

DOUBLE returns ecore::EDouble: INT? '.' INT;
DATE returns ecore::EDate:'EDate' /* TODO: implement this rule and an appropriate IValueConverter */;

/*
// automatically generated by Xtext
grammar de.hub.modsoft.excercise6.twittersearch.TwitterSearch with org.eclipse.xtext.common.Terminals

import "http://www.hu-berlin.de/modsoft/TwitterSearch/1.0" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Twitter returns Twitter:
	{Twitter}
	'Twitter'
	'{'
		('objectTypes' '{' objectTypes+=TwitterObjectType ( "," objectTypes+=TwitterObjectType)* '}' )?
		('searches' '{' searches+=Search ( "," searches+=Search)* '}' )?
	'}';




Condition returns Condition:
	BooleanCondition | StringCondition | IntCondition;


SearchOption returns SearchOption:
	Keywords | Location | Time;

TwitterObjectType returns TwitterObjectType:
	{TwitterObjectType}
	'TwitterObjectType'
	name=EString
	'{'
		('fields' '{' fields+=FieldDeclaration ( "," fields+=FieldDeclaration)* '}' )?
	'}';

Search returns Search:
	{Search}
	'Search'
	'{'
		('searchFor' searchFor=[TwitterObjectType|EString])?
		('conditions' '{' conditions+=Condition ( "," conditions+=Condition)* '}' )?
		('sortation' sortation=FieldExpr)?
		('options' '{' options+=SearchOption ( "," options+=SearchOption)* '}' )?
	'}';

EString returns ecore::EString:
	STRING | ID;

FieldDeclaration returns FieldDeclaration:
	{FieldDeclaration}
	'FieldDeclaration'
	name=EString
	'{'
		('fieldType' fieldType=FieldTypes)?
	'}';

enum FieldTypes returns FieldTypes:
				int = 'int' | string = 'string' | boolean = 'boolean';

FieldExpr returns FieldExpr:
	{FieldExpr}
	'FieldExpr'
	'{'
		('fieldDeclaration' fieldDeclaration=[FieldDeclaration|EString])?
	'}';

BooleanCondition returns BooleanCondition:
	'BooleanCondition'
	'{'
		'field' field=FieldExpr
	'}';

StringCondition returns StringCondition:
	'StringCondition'
	'{'
		('operand' operand=EString)?
		('operator' operator=StringOperators)?
		'field' field=FieldExpr
	'}';

IntCondition returns IntCondition:
	'IntCondition'
	'{'
		('operand' operand=EInt)?
		('operator' operator=IntOperators)?
		'field' field=FieldExpr
	'}';

enum StringOperators returns StringOperators:
				contains = 'contains' | containsnot = 'containsnot';

EInt returns ecore::EInt:
	'-'? INT;

enum IntOperators returns IntOperators:
				gt = 'gt' | lt = 'lt' | eq = 'eq' | geq = 'geq' | leq = 'leq';

Keywords returns Keywords:
	{Keywords}
	'Keywords'
	'{'
		('keywords' '{' keywords+=EString ( "," keywords+=EString)* '}' )?
	'}';

Location returns Location:
	{Location}
	'Location'
	'{'
		('lon' lon=EDouble)?
		('lat' lat=EDouble)?
		('radius' radius=EDouble)?
		('radiusUnit' radiusUnit=DistanceUnit)?
	'}';

Time returns Time:
	{Time}
	'Time'
	'{'
		('before' before=EDate)?
		('after' after=EDate)?
	'}';

EDouble returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;

enum DistanceUnit returns DistanceUnit:
				miles = 'miles' | kilometers = 'kilometers';

EDate returns ecore::EDate:
	'EDate'; // TODO: implement this rule and an appropriate IValueConverter
*/
